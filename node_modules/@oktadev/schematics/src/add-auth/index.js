"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.capacitor2x = exports.ionicRemoteConfig = exports.cordovaNode = exports.addAuth = exports.EXPRESS = exports.IONIC_ANGULAR = exports.VUE3_TS = exports.VUE3 = exports.VUE_TS = exports.VUE = exports.REACT_NATIVE = exports.REACT_TS = exports.REACT = exports.ANGULAR = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const workspace_1 = require("@schematics/angular/utility/workspace");
const project_targets_1 = require("@schematics/angular/utility/project-targets");
const sdk_versions_json_1 = require("../sdk-versions.json");
const satisfies_1 = __importDefault(require("semver/functions/satisfies"));
const coerce_1 = __importDefault(require("semver/functions/coerce"));
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const schematics_2 = require("@angular/cdk/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const change_1 = require("@schematics/angular/utility/change");
const OKTA_AUTH_JS_VERSION = sdk_versions_json_1.dependencies['@okta/okta-auth-js'];
const OKTA_ANGULAR_VERSION = sdk_versions_json_1.dependencies['@okta/okta-angular'];
const OKTA_REACT_VERSION = sdk_versions_json_1.dependencies['@okta/okta-react'];
const REACT_ROUTER_DOM_VERSION = sdk_versions_json_1.dependencies['react-router-dom'];
const REACT_ROUTER_DOM_TYPES_VERSION = sdk_versions_json_1.dependencies['@types/react-router-dom'];
const OKTA_REACT_NATIVE_VERSION = sdk_versions_json_1.dependencies['@okta/okta-react-native'];
const EVENTS_VERSION = sdk_versions_json_1.dependencies['events'];
const ENZYME_VERSION = sdk_versions_json_1.dependencies['enzyme'];
const ENZYME_ADAPTER_VERSION = sdk_versions_json_1.dependencies['enzyme-adapter-react-16'];
const ENZYME_ASYNC_VERSION = sdk_versions_json_1.dependencies['enzyme-async-helpers'];
const REACT_DOM_VERSION = sdk_versions_json_1.dependencies['react-dom'];
const OKTA_VUE2_VERSION = sdk_versions_json_1.dependencies['@okta/okta-vue2'];
const OKTA_VUE3_VERSION = sdk_versions_json_1.dependencies['@okta/okta-vue'];
const IONIC_APPAUTH_VERSION = sdk_versions_json_1.dependencies['ionic-appauth'];
const IONIC_SECURE_STORAGE_VERSION = sdk_versions_json_1.dependencies['@ionic-native/secure-storage'];
const IONIC_CORDOVA_SECURE_STORAGE_VERSION = sdk_versions_json_1.dependencies['cordova-plugin-secure-storage-echo'];
const IONIC_CORDOVA_ADVANCED_HTTP_VERSION = sdk_versions_json_1.dependencies['cordova-plugin-advanced-http'];
const IONIC_CORDOVA_FILE_VERSION = sdk_versions_json_1.dependencies['cordova-plugin-file'];
const IONIC_NATIVE_HTTP_VERSION = sdk_versions_json_1.dependencies['@ionic-native/http'];
const IONIC_CORDOVA_SAFARIVIEWCONTROLLER_VERSION = sdk_versions_json_1.dependencies['cordova-plugin-safariviewcontroller'];
const IONIC_STORAGE_VERSION = sdk_versions_json_1.dependencies['@ionic/storage'];
const IONIC_STORAGE_ANGULAR_VERSION = sdk_versions_json_1.dependencies['@ionic/storage-angular'];
const IONIC_SPLASH_SCREEN_VERSION = sdk_versions_json_1.dependencies['@ionic-native/splash-screen'];
const IONIC_STATUS_BAR_VERSION = sdk_versions_json_1.dependencies['@ionic-native/status-bar'];
const EXPRESS_SESSION_VERSION = sdk_versions_json_1.dependencies['express-session'];
const OKTA_OIDC_MIDDLEWARE_VERSION = sdk_versions_json_1.dependencies['@okta/oidc-middleware'];
const DOTENV_VERSION = sdk_versions_json_1.dependencies['dotenv'];
function addPackageJsonDependencies(framework, options) {
    return (host, context) => {
        const dependencies = [];
        if (framework === exports.ANGULAR) {
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: OKTA_ANGULAR_VERSION, name: '@okta/okta-angular' });
        }
        else if (framework === exports.REACT || framework === exports.REACT_TS) {
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: OKTA_REACT_VERSION, name: '@okta/okta-react' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: OKTA_AUTH_JS_VERSION, name: '@okta/okta-auth-js' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: REACT_ROUTER_DOM_VERSION, name: 'react-router-dom' });
            if (framework === exports.REACT_TS) {
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: REACT_ROUTER_DOM_TYPES_VERSION, name: '@types/react-router-dom' });
            }
        }
        else if (framework === exports.REACT_NATIVE) {
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: OKTA_REACT_NATIVE_VERSION, name: '@okta/okta-react-native' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: EVENTS_VERSION, name: 'events' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Dev, version: ENZYME_VERSION, name: 'enzyme' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Dev, version: ENZYME_ADAPTER_VERSION, name: 'enzyme-adapter-react-16' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Dev, version: ENZYME_ASYNC_VERSION, name: 'enzyme-async-helpers' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Dev, version: REACT_DOM_VERSION, name: 'react-dom' });
        }
        else if (framework === exports.VUE || framework === exports.VUE_TS || framework === exports.VUE3 || framework === exports.VUE3_TS) {
            const oktaVueVersion = (framework === exports.VUE || framework === exports.VUE_TS) ? OKTA_VUE2_VERSION : OKTA_VUE3_VERSION;
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: oktaVueVersion, name: '@okta/okta-vue' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: OKTA_AUTH_JS_VERSION, name: '@okta/okta-auth-js' });
        }
        else if (framework === exports.IONIC_ANGULAR) {
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_APPAUTH_VERSION, name: 'ionic-appauth' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_SECURE_STORAGE_VERSION, name: '@ionic-native/secure-storage' });
            if (options.platform === 'capacitor') {
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_CORDOVA_SECURE_STORAGE_VERSION, name: 'cordova-plugin-secure-storage-echo' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_CORDOVA_ADVANCED_HTTP_VERSION, name: 'cordova-plugin-advanced-http' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_CORDOVA_FILE_VERSION, name: 'cordova-plugin-file' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_CORDOVA_SAFARIVIEWCONTROLLER_VERSION, name: 'cordova-plugin-safariviewcontroller' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_NATIVE_HTTP_VERSION, name: '@ionic-native/http' });
            }
            else {
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_STORAGE_VERSION, name: '@ionic/storage' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_STORAGE_ANGULAR_VERSION, name: '@ionic/storage-angular' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_SPLASH_SCREEN_VERSION, name: '@ionic-native/splash-screen' });
                dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: IONIC_STATUS_BAR_VERSION, name: '@ionic-native/status-bar' });
            }
        }
        else if (framework === exports.EXPRESS) {
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: EXPRESS_SESSION_VERSION, name: 'express-session' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: OKTA_OIDC_MIDDLEWARE_VERSION, name: '@okta/oidc-middleware' });
            dependencies.push({ type: dependencies_1.NodeDependencyType.Default, version: DOTENV_VERSION, name: 'dotenv' });
        }
        dependencies.forEach(dependency => {
            dependencies_1.addPackageJsonDependency(host, dependency);
            // @ts-ignore
            context.logger.log('info', `‚úÖÔ∏è Added '${dependency.name}' into ${dependency.type}`);
        });
        return host;
    };
}
function installPackageJsonDependencies() {
    return (host, context) => {
        context.addTask(new tasks_1.NodePackageInstallTask());
        context.logger.log('info', `üîç Installing packages...`);
        return host;
    };
}
exports.ANGULAR = 'angular';
exports.REACT = 'react';
exports.REACT_TS = 'react-ts';
exports.REACT_NATIVE = 'react-native';
exports.VUE = 'vue';
exports.VUE_TS = 'vue-ts';
exports.VUE3 = 'vue3';
exports.VUE3_TS = 'vue3-ts';
exports.IONIC_ANGULAR = 'ionic/angular';
exports.EXPRESS = 'express';
function getFramework(host) {
    var _a;
    let possibleFiles = ['/package.json'];
    const path = possibleFiles.filter(path => host.exists(path))[0];
    const configBuffer = host.read(path);
    if (configBuffer === null) {
        throw new schematics_1.SchematicsException(`Could not find (${path})`);
    }
    else {
        const content = JSON.parse(configBuffer.toString());
        if (content.dependencies['@angular/core'] && !content.dependencies['@ionic/angular']) {
            return exports.ANGULAR;
        }
        else if (content.dependencies['react']) {
            if (content.dependencies['react-native']) {
                return exports.REACT_NATIVE;
            }
            if (content.dependencies['typescript']) {
                return exports.REACT_TS;
            }
            return exports.REACT;
        }
        else if (content.dependencies['vue']) {
            const vueVersion = content.dependencies['vue'];
            const currentVersion = (_a = coerce_1.default(vueVersion)) === null || _a === void 0 ? void 0 : _a.version;
            const vue3 = (currentVersion) ? satisfies_1.default(currentVersion, '>=3.0.0') : false;
            if (vue3) {
                return (content.devDependencies['@vue/cli-plugin-typescript']) ? exports.VUE3_TS : exports.VUE3;
            }
            else {
                return (content.devDependencies['typescript']) ? exports.VUE_TS : exports.VUE;
            }
        }
        else if (content.dependencies['@ionic/angular']) {
            return exports.IONIC_ANGULAR;
        }
        else if (content.dependencies['express']) {
            return exports.EXPRESS;
        }
        else {
            throw new schematics_1.SchematicsException('No supported frameworks found in your package.json!');
        }
    }
}
function addAuth(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        // allow passing the framework in (for testing)
        let framework = options.framework;
        // if no framework defined, try to detect it
        if (!framework) {
            framework = getFramework(host);
        }
        let projectPath = './';
        if (framework === exports.ANGULAR) {
            const workspace = yield workspace_1.getWorkspace(host);
            if (!options.issuer) {
                throw new schematics_1.SchematicsException('You must specify an "issuer".');
            }
            if (!options.project) {
                options.project = workspace.projects.keys().next().value;
            }
            const project = workspace.projects.get(options.project);
            if (!project) {
                throw new schematics_1.SchematicsException(`Invalid project name: ${options.project}`);
            }
            projectPath = project.root;
            const buildTarget = (_a = project.targets) === null || _a === void 0 ? void 0 : _a.get('build');
            if (!buildTarget) {
                throw project_targets_1.targetBuildNotFoundError();
            }
            const buildOptions = (buildTarget.options || {});
            if (buildOptions.styles) {
                let style = buildOptions.styles[0];
                if (style) {
                    options.style = style.substring(style.lastIndexOf('.') + 1, style.length);
                }
                else {
                    options.style = 'css';
                }
            }
            // add imports to app.module.ts
            schematics_2.addModuleImportToModule(host, projectPath + '/src/app/app.module.ts', 'AuthRoutingModule', './auth-routing.module');
        }
        if (framework == exports.IONIC_ANGULAR) {
            // add a package name from the issuer
            const parts = options.issuer.split('.');
            if (options.issuer.indexOf('.') === -1) {
                // hard-code a package name for localhost
                options.packageName = 'dev.localhost.ionic';
            }
            else {
                options.packageName =
                    parts[2].substring(0, parts[2].indexOf('/')) + '.'
                        + parts[1] + '.'
                        + parts[0].substring(parts[0].lastIndexOf('/') + 1);
            }
            // create AuthConfigService for JHipster
            if (options.configUri) {
                host.create('src/app/auth/auth-config.service.ts', ionicRemoteConfig(options.configUri));
            }
            // add cordova to package.json
            if (options.platform === 'cordova') {
                const content = host.read('./package.json');
                if (content) {
                    const pkgJson = JSON.parse(content.toString());
                    // save any pre-existing plugins
                    if (pkgJson.cordova && pkgJson.cordova.plugins) {
                        const existingPlugins = pkgJson.cordova.plugins;
                        pkgJson.cordova.plugins = Object.assign(Object.assign({}, cordovaNode(options.packageName).plugins), existingPlugins);
                        pkgJson.cordova.platforms = cordovaNode(options.packageName).platforms;
                    }
                    else {
                        pkgJson.cordova = cordovaNode(options.packageName);
                    }
                    host.overwrite('./package.json', JSON.stringify(pkgJson));
                }
                schematics_2.addModuleImportToModule(host, 'src/app/app.module.ts', 'IonicStorageModule.forRoot()', '@ionic/storage-angular');
                // add SplashScreen and StatusBar providers for Cordova
                const moduleSource = schematics_2.parseSourceFile(host, 'src/app/app.module.ts');
                const splashScreenChanges = ast_utils_1.addProviderToModule(moduleSource, 'src/app/app.module.ts', 'SplashScreen', '@ionic-native/splash-screen/ngx');
                const statusBarChanges = ast_utils_1.addProviderToModule(moduleSource, 'src/app/app.module.ts', 'StatusBar', '@ionic-native/status-bar/ngx');
                const updater = host.beginUpdate('./src/app/app.module.ts');
                for (const change of splashScreenChanges) {
                    if (change instanceof change_1.InsertChange) {
                        updater.insertRight(change.pos, change.toAdd);
                    }
                }
                for (const change of statusBarChanges) {
                    if (change instanceof change_1.InsertChange) {
                        updater.insertRight(change.pos, change.toAdd);
                    }
                }
                host.commitUpdate(updater);
            }
            else {
                // Force Capacitor 2.x until secure-storage is fixed.
                // https://github.com/martinkasa/capacitor-secure-storage-plugin/issues/30
                host.create('npm-shrinkwrap.json', capacitor2x());
            }
            // add imports to app.module.ts
            schematics_2.addModuleImportToModule(host, 'src/app/app.module.ts', 'HttpClientModule', '@angular/common/http');
            schematics_2.addModuleImportToModule(host, 'src/app/app.module.ts', 'AuthModule', './auth/auth.module');
            // Add new modules to tsconfig.app.json
            const tsConfig = host.read('./tsconfig.app.json');
            if (tsConfig) {
                let config = tsConfig.toString();
                config = config.replace('"src/polyfills.ts"', `"src/polyfills.ts",
    "src/app/auth/auth-callback/auth-callback.module.ts",
    "src/app/auth/end-session/end-session.module.ts",
    "src/app/login/login.module.ts",
    "src/app/tabs/tabs.module.ts"`);
                host.overwrite('./tsconfig.app.json', config);
            }
        }
        if (framework === exports.REACT || framework === exports.REACT_TS) {
            const jestConfig = {
                'moduleNameMapper': {
                    '^@okta/okta-auth-js$': '<rootDir>/node_modules/@okta/okta-auth-js/dist/okta-auth-js.umd.js'
                }
            };
            const content = host.read('./package.json');
            if (content) {
                const pkgJson = JSON.parse(content.toString());
                pkgJson.jest = jestConfig;
                host.overwrite('./package.json', JSON.stringify(pkgJson));
            }
        }
        if (framework === exports.REACT_NATIVE) {
            // add a package name from the issuer
            const parts = options.issuer.split('.');
            options.packageName = parts[2].substring(0, parts[2].indexOf('/')) + '.'
                + parts[1] + '.' + parts[0].substring(parts[0].lastIndexOf('/') + 1);
            const content = host.read('./package.json');
            if (content) {
                const pkgJson = JSON.parse(content.toString());
                // add jest config for tests
                pkgJson.jest = {
                    'preset': 'react-native',
                    'automock': false,
                    'testEnvironment': 'jsdom',
                    'transformIgnorePatterns': [
                        'node_modules/(?!@okta|@react-native|react-native)'
                    ],
                    'testMatch': ['**/tests/*.js?(x)', '**/?(*.)(spec|test).js?(x)'],
                    'setupFiles': [
                        './setupJest.js'
                    ]
                    // The reason tests are in `tests` instead of `__tests__` is because
                    // schematics uses double underscore as a substitution indicator in filenames.
                    // If you try to put tests in __tests__, you'll get an error:
                    // Error: Option "tests" is not defined.
                };
                host.overwrite('./package.json', JSON.stringify(pkgJson));
                // Upgrade iOS to v11
                const podfile = host.read('./ios/Podfile');
                if (podfile) {
                    const ios11 = podfile.toString('utf-8').replace('platform :ios, \'10.0\'', 'platform :ios, \'11.0\'');
                    host.overwrite('ios/Podfile', ios11);
                }
                // Configure Gradle for App
                const appBuild = host.read('./android/app/build.gradle');
                if (appBuild) {
                    const redirectScheme = appBuild.toString('utf-8')
                        .replace('versionName "1.0"', 'versionName "1.0"\n        manifestPlaceholders = [ appAuthRedirectScheme: "' + options.packageName + '" ]');
                    host.overwrite('android/app/build.gradle', redirectScheme);
                }
            }
        }
        // Setup templates to add to the project
        const sourceDir = (framework !== exports.REACT_NATIVE && framework !== exports.EXPRESS) ? 'src' : '';
        const sourcePath = core_1.join(core_1.normalize(projectPath), sourceDir);
        const templatesPath = core_1.join(sourcePath, '');
        const templateSource = schematics_1.apply(schematics_1.url(`./${framework}/${sourceDir}`), [
            schematics_1.template(Object.assign({}, options)),
            schematics_1.move(core_1.getSystemPath(templatesPath))
        ]);
        // Chain the rules and return
        return schematics_1.chain([
            options && options.skipPackageJson ? schematics_1.noop() : addPackageJsonDependencies(framework, options),
            options && options.skipPackageJson ? schematics_1.noop() : installPackageJsonDependencies(),
            schematics_1.mergeWith(templateSource, schematics_1.MergeStrategy.Overwrite),
        ]);
    });
}
exports.addAuth = addAuth;
function cordovaNode(packageName) {
    return {
        'plugins': {
            'cordova-plugin-advanced-http': {},
            'cordova-plugin-safariviewcontroller': {},
            'cordova-plugin-inappbrowser': {},
            'cordova-plugin-secure-storage-echo': {},
            'cordova-plugin-customurlscheme': {
                'URL_SCHEME': packageName
            },
            'cordova-plugin-whitelist': {},
            'cordova-plugin-statusbar': {},
            'cordova-plugin-device': {},
            'cordova-plugin-splashscreen': {},
            'cordova-plugin-ionic-webview': {
                'ANDROID_SUPPORT_ANNOTATIONS_VERSION': '27.+'
            },
            'cordova-plugin-ionic-keyboard': {}
        },
        'platforms': [
            'android',
            'ios'
        ]
    };
}
exports.cordovaNode = cordovaNode;
function ionicRemoteConfig(configUri) {
    return `import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root'
})
export class AuthConfigService {
  private authConfig;

  constructor(private http: HttpClient) { }

  loadAuthConfig() {
    return this.http.get(\`\${environment.apiUrl}/${configUri}\`)
      .toPromise()
      .then(data => {
        this.authConfig = data;
        // Override issuer and client ID with values from API
        environment.oidcConfig.server_host = this.authConfig.issuer;
        environment.oidcConfig.client_id = this.authConfig.clientId;
      }).catch((error) => {
        console.error('Failed to fetch remote OIDC configuration.');
        console.error(error);
      });
  }

  getConfig() {
    return this.authConfig;
  }
}`;
}
exports.ionicRemoteConfig = ionicRemoteConfig;
function capacitor2x() {
    return `{
  "dependencies": {
    "capacitor-secure-storage-plugin": {
      "version": "0.4.0",
      "dependencies": {
        "@capacitor/core": {
          "version": "2.4.7"
        }
      }
    }
  }
}`;
}
exports.capacitor2x = capacitor2x;
//# sourceMappingURL=index.js.map